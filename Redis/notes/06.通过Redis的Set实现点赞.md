# Redis 其他数据类型的使用

---

## 1. 使用set 实现点赞与取消点赞

问题： 一个用户可以无限次的刷点赞，虽然数据库可以记录该信息，但是性能不好，所以可以使用redis 的set数据结构，将数据库中已经保存的点赞信息在启动时就加载到redis中
即可实现已经点赞的人员过滤；当有新用户点赞的时候，可以先将点赞的信息存入redis并落库。待下一次用户点击按钮时，可以通过redis快速判断出是否为重复点击，从而实现点赞
与取消点赞。

    将文章作为set的key，点赞用户作为values， 每次点赞的时候查询是否点赞过。

---

## 2. 使用sortedSet（ZSet）实现点赞排行榜

        技巧： zset 没有直接查询一个元素是否存在的方法，可以使用查询一个元素score的方法，有分数代表元素存在，没有分数则不存在。

---

## 3. 使用set 交集实现共同关注

将每个用户的关注列表存储到set集合中，当获取共同关注的时候计算两个集合的交集即可。

## 4. 关注推送 Feed流

feed流的两种常见模式

1. Timeline： 不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注。例如朋友圈
    
        优点： 信息全面，不会有丢失。并且实现也相对简单
        缺点： 信息噪音较多，用户不一定感兴趣，内容获取率低

2. 智能排序： 利用智能算法屏蔽掉违规的、用户不感兴趣的内容。推送用户感兴趣信息来吸引用户

        优点： 投喂用户感兴趣信息，用户黏度很高，容易沉迷
        缺点： 如果算法不精准，可能起到反作用

Feed流实现方案：

1. 拉模式： 也叫做读扩散，每个人发消息到自己的发件箱，目标用户只有在读取收件箱的时候才会从指定用户的发件箱中拉取对应的消息。缺点： 延迟、数据量
2. 推模式： 也叫做写扩散， 每个用户发消息的时候，直接推送到所有目标用户的收件箱中。缺点：一个消息N份，占用空间。
3. 推拉结合： 也叫读写混合，对于目标用户少的，可以使用推模式直接推送给用户，数据量不大；对于大V目标用户多的，将目标用户分为活跃与非活跃，活跃的使用推模式，不活跃的用户使用拉模式。

Feed流分页问题：

    Feed流中的数据会不断更新，所以数据的角标也在变化（即顺序变化），因此不能采用传统的分页模式。使用滚动分页模式（记录上一次查询的最后一条，下一次从这条继续查） --> 使用sortedSet中的score值作为角标进行滚动查询即可。

