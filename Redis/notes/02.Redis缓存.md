# Redis 缓存

---

缓存就是数据交换的缓冲区，称作cache，是贮存数据的临时地方，一般读写性能较高。

缓存的作用：

1. 降低后端负载
2. 提高读写效率，降低响应时间

使用缓存的成本

1. 数据一致性成本
2. 代码维护成本
3. 运维成本

---

## 添加Redis缓存

缓存作用模型： 

![缓存模型](img/cache-model.png)

查询模型：

    1. 查询redis是否存在
    2. 存在直接返回结果
    3. 不存在，查询数据库
    4. 数据库不存在，直接返回未找到
    5. 数据库存在，更新到缓存中
    6. 返回结果

---

## 缓存更新策略

||内存淘汰|超时剔除|主动更新|
|---|---|---|---|
|说明|不用自己维护，利用Redis的内存淘汰机制，当内存不足时自动淘汰部分数据，下次查询时再更新缓存|给缓存数据添加TTL时间，到期后自动删除缓存，下次查询时更新缓存|编写业务逻辑，在修改数据库的同时，更新缓存|
|一致性|差|一般|好|
|维护成本|无|底|高|


业务场景：

1. 低一致性需求： 使用内存淘汰机制。例如店铺类型的查询缓存
2. 高一致性需求： 主动更新，并以超时剔除作为兜底方案。例如店铺详情查询的缓存

主动更新策略

    cache aside pattern： 由缓存的调用者，在更新数据库的同时更新缓存
    Read/Write through pattern: 缓存与数据库整合为一个服务，由服务来维护一致性，调用着调用该服务，无序关心缓存一致性问题
    Write Behind Caching Pattern： 调用者只操作缓存，由其他线程异步的将缓存数据持久化到数据库，保证最终一致。

几个考虑的点：

1. 删除缓存还是更新缓存？

        更新缓存： 每次更新数据库都更新缓存，无效写操作多
        删除缓存： 更新数据库时让缓存失效，查询时再更新缓存  √

2. 如何保证缓存与数据库的操作同时成功或者失败？

        单体系统： 将缓存与数据库操作放在一个事物
        分布式系统： 利用TCC等分布式事物方案

3. 先操作缓存还是先操作数据库？

        一般是先操作数据库再删缓存.    

最佳实践方案：

1. 低一致性要求： 使用Redis自带的内存淘汰机制

2. 高一致性要求： 主动更新，并以超时剔除作为兜底方案

        读操作： 
            缓存命中直接返回
            缓存未命中则查询数据库并写入缓存，设定超时时间
        写操作：
            先写数据库，然后再删除缓存
            要确保数据库与缓存操作的原子性

---

## 缓存穿透

缓存穿透是指客户端请求的数据在缓存和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。

常见解决方案

1. 缓存空对象

        优点： 实现简单，维护方便
        缺点： 额外的内存消耗，可能造成短期的不一致

2. 布隆过滤

        优点： 内存占用少，没有多余的key
        缺点： 实现复杂，存在误判可能

3. 增加id的强度，避免被猜测id规律
4. 做好数据的基础格式校验

---

## 缓存雪崩

缓存雪崩是指在同一时间段内大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。

解决方案

1. 给不同的key添加不同的ttl值
2. 利用redis集群提高服务的可用性
3. 给缓存业务添加降级限流策略
4. 给业务添加多级缓存

---

## 缓存击穿

缓存击穿问题也叫热点key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。

常见解决方案：

1. 互斥锁

        同一时间段内只有一个线程能够重建缓存，但是会导致其他线程等待。

2. 逻辑过期

        不再设置TTL而是使用自定义字段去维护过期时间。待活动完成后主动删除。但是可能会导致取到旧数据。

|解决方案|优点|缺点|
|-------|---|---|
|互斥锁| 没有额外的内存消耗<br>保证一致性<br>实现简单|线程需要等待，性能受影响<br>可能有死锁风险|
|逻辑过期|线程无需等待，性能较好|不保证一致性<br>有额外的内存消耗<br>实现复杂|



