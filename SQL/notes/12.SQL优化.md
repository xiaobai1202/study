# SQL 优化

---

## 插入数据优化

1. 批量操作 insert into 表 values(元组),(元组),(元组)

2. 手动事物提交

3. 主键顺序插入

如果需要一次性插入大批量数据，可以使用是mysql的load指令:

    # 客户端连接服务端时，加上 --local-infile 参数
    mysql --local-infile -u root -p
    # 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关
    set global local_infile=1
    # 执行load指令将准备好的数据加载到表结构中
    load data local infile '本地文件' into table 表 fields terminated by '字段分割符' lines terminated by '行分隔符';

---

## 主键优化

1. 数据组织方式

    在innoDB存储引擎中，表数据都是根据主键顺序组织的，这种存储方式的表称为索引组织表（IOT）

2. 页分裂

    页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据（如果一行数据过大，会行溢出），根据主键排列。
    
    主键乱序插入可能会导致页分裂。

3. 页删除

    当删除一行记录时，实际上记录并没有被物理删除，只是被标记为删除并且它的空间变得允许被其他记录声明使用。

    当页中删除的记录达到MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找靠近的页（前或后）看看是否可以将两个页合并以优化空间使用。

4. 主键设计原则

   1. 在满足业务需求的情况下,尽量降低主键长度
   2. 插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键
   3. 尽量不要使用UUID作为主键或者是其他自然主键，比如身份证号
   4. 业务操作时尽量避免对主键的修改

---

## order by 优化

1. 两种排序方式：
   1. Using FileSort： 通过表的索引或者全表扫描读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫FileSort排序
   2. Using Index： 通过有序索引顺序扫描直接返回有序数据，这种情况即为using index，不需要额外排序，操作效率高

    可以在创建索引的时候指定索引顺序来使查询走索引（一定要覆盖索引才生效）

2. 建议：
    
   1. 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则
   2. 尽量使用覆盖索引
   3. 多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则。
   4. 如果不可避免的出现fileSort，大量数据排序时，可以适当增大排序缓冲区大小 sort_buffer_size(默认为256K)

---

## group by 优化

分组操作时也可以通过索引提高效率。同时，分组操作的索引也是满足最左前缀法则的。

---

## limit 优化

limit 大数据量分页越往后耗时越长（没有索引时） limit 100000,10 其实是查询了100010条并丢弃了前面的100000条

优化思路： 一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引+子查询形式进行优化

---

## count 优化

MyISAM 引擎把一个表总行数存在了磁盘上，因此执行count(*)的时候会直接返回这个数据，效率非常高。

但是InnoDB就麻烦了，他执行count(*)的时候，需要把所有数据都从引擎里面读出来，然后累积计数。

优化思路：  自行计数....

几种用法：

count(主键):  遍历整张表id计数  
count(字段): 没有not null 遍历+判断不为null计数，有not null 和count主键一样
count(*): 不取值，直接取出每行累加
count(1): 遍历整张表，每一行放一个数字1 累加

按照效率排序：  count(*) ≈ count(1) > count(主键id) > count(字段)

---

## update 优化

InnoDB的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则行锁会自动升级为表锁.