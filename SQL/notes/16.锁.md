# 锁

---

MYSQL中的锁按照粒度来分，分为以下三类

1. 全局锁： 锁定数据库中所有的表
2. 表级锁： 每次操作锁住整张表
3. 行级锁： 每次操作锁住对应的行数据

---

## 全局锁

全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句以及更新操作的事物提交语句都将被阻塞。其典型的使用场景就是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性

语法：

    加全局锁： flush tables with read lock;

    解锁： unlock tables;

特点

    1. 如果是在主库上备份，那么在备份期间都不能执行更新，业务基本不可用
    2. 如果在从库上备份，那么在备份期间从库都不能执行主库同步过来的二进制日志，会导致主从延迟

在InnoDB引擎中，我们可以在备份的时候加上参数 --single-transaction参数来完成不加锁的一致性数据备份

---

## 表级锁

表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM InnoDB BDB等存储引擎中

对于表级锁主要分为以下三类：

1. 表锁

   1. 表共享读锁 read lock
            
            不会阻塞自己的读和其他客户端的读，不允许自己写，阻塞其他客户端写
   2. 表独占写锁 write lock
            
            不会阻塞自己的读写，阻塞其他客户端的读写
    
   加锁： lock tables 表名...  read/write

   解锁： unlock tables / 客户端断开连接

2. 元数据锁（meta data lock， MDL）
    
    MDL 加锁过程是系统自动控制，无需显示使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事物的时候，不可以对元数据进行写入操作。
    
    避免DML与DDL冲突，保证读写的正确性

    | 对应SQL                                      | 锁类型                                   | 说明                                        |
    |--------------------------------------------|---------------------------------------|-------------------------------------------|
    | lock tables xxx read/write                 | SHARED_READ_ONLY/SHARED_NO_READ_WRITE |                                           |
    | select、select ... lock in share model      | SHARED_READ                           | 与SHARED_READ、SHARED_WRITE兼容、与EXCLUSIVE 互斥 |
    | insert、update、delete、select ... for update | SHARED_WRITE                          | 与SHARED_READ、SHARED_WRITE兼容、与EXCLUSIVE 互斥 |
    | alter table                                | EXCLUSIVE                             | 与其他的MDL都互斥                                |

3. 意向锁
 
    为了避免DML在执行时加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁得检查
    
   1. 意向共享锁（IS）： 由语句 select ... lock in share mode 添加
        与表锁共享锁兼容，与表锁排他锁互斥
   2. 意向排他锁（IX）： 由语句 insert、 update、delete、select... for update 添加
        与表共享及排他锁均互斥，意向锁之间不会互斥

---

## 行级锁

行级锁，每次操作锁住对应得行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中

MYSQL 中查看行锁的SQL: SELECT object_schema,object_name,index_name,lock_type,lock_mode,lock_data FROM PERFORMANCE_SCHEMA.DATA_LOCKS; 

InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级锁主要分为三类：

1. 行锁（record lock） 锁定单个记录的锁，防止其他事物对此进行update和delete，在RC\RR隔离级别下都支持

   1. 共享锁（s）： 允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
   2. 排他锁（x）： 允许获取排他锁的事物更新数据，阻止其他事务获得相同数据集的共享锁和排他锁
   
   默认sql 增加的行锁类型

   | SQL                         | 行锁类型      | 说明                               |
   |-----------------------------|-----------|----------------------------------|
   | INSERT...                   | 排他锁       | 自动加锁                             |
   | UPDATE                      | 排他锁       | 自动加锁                             |
   | DELETE...                   | 排他锁       | 自动加锁                             |
   | SELECT（正常）                  | **不加任何锁** |                                  |
   | SELECT...LOCK IN SHARE MODE | 共享锁       | 需要手动在select之后加lock in share mode |
   | SELECT ... FOR UPDATE       | 排他锁       | 需要手动在select之后加for update         |

    默认情况下，InnoDB在REPEATABLE READ 事务隔离级别运行，InnoDB使用next-key锁进行搜索和索引扫描，以防止幻读。
        
        1. 针对唯一索引进行检索时， 对已存在的记录进行等值匹配时，将会自动优化为行锁
        2. InnoDB 的行锁是针对索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会升级为表锁

2. 间隙锁（Gap lock） 锁定索引记录的间隙（不含该记录），确保索引间隙不变，防止其他事物在这个间隙进行insert，产生幻读。在RR隔离级别下都支持
3. 临键锁（Next-Key lock） 行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持

默认情况下InnoDB在REPEATABLE READ事物隔离级别下运行，InnoDB使用next-key锁进行搜索和索引扫描，以防止幻读

1. 索引上的等值查询（唯一索引），给不存在的记录加锁时，优化为间隙锁。
2. 索引上的等值查询（普通索引），享有遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁
3. 索引上的范围查询（唯一索引），会访问到不满足条件的第一个值为止

**注意： 间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事物采用的间隙锁不会阻止另一个事物在同一间隙上采用间隙锁**



